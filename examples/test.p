let x = 1.00001;
x;
1.1;
1;
1e10;
.1;
0000000;
x + 1;
let y = 1.1;
-2^3;
+x^y;
-x^y;
-x^(y+1);
-x^y+1;
-1*x^y;
-1+x^y;
let v=0;
-1+(v+1)^(y+1);
2^3^4;
let a = 2;
let b = 3;
let c = 4;
a/b/c;
y < y;
clock();
assert(y <= y);
let f = \x -> { x^2; };;
f(1)

let result = f(2.0)^f(2.0);
assert(result == 4.0^4.0)

f;
let f2 = \x y -> (x^2 + y^2);;
f2;

"";

"ðŸŽ ðŸª ð•­ð–”ð–Žð–‘ð–Šð–—â¸—ð–•ð–‘ð–†ð–™ð–Š ð–‹ð–”ð–— ð–€ð–“ð–Žð–ˆð–”ð–‰ð–Šâ¸—ð•¬ð–œð–†ð–—ð–Š ð•®ð–”ð–‰ð–Š ðŸª ðŸŽ";
f(x)^f(x);

let mut mx = 1;
mx = 3;
{ mx = 2; };;

\x -> {
        y;
};;
\x -> y;;

let cond = ((1 > 2) ? x : y)
assert(cond == y)

// "x" + "y"

let asdf = 1 + 2
asdf

assert(asdf == 3)

# more comments

asdf

let f = \x -> x^2
assert(4 == f(2))
let f2 = \x -> f(x)
f2(3)

# recursion
let f1 = \x -> (x < 10) ? f1(x+1): false
f1(1)
